创建型：将对象的创建和使用分离
单例模式：
  单例类只有一个实例对象；
  该单例对象必须由单例类自行创建；
  单例类对外提供一个访问该单例的全局访问点；
  懒汉式单例
  public class LazySingleton
{
    private static volatile LazySingleton instance=null;    //保证 instance 在所有线程中同步
    private LazySingleton(){}    //private 避免类在外部被实例化
    public static synchronized LazySingleton getInstance()
    {
        //getInstance 方法前加同步
        if(instance==null)
        {
            instance=new LazySingleton();
        }
        return instance;
    }
}
  饥汉式单例
  public class HungrySingleton
{
    private static final HungrySingleton instance=new HungrySingleton();
    private HungrySingleton(){}
    public static HungrySingleton getInstance()
    {
        return instance;
    }
}

原型模式：用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。
  原型模式通常适用于以下场景。
  对象之间相同或相似，即只是个别的几个属性不同的时候。
  对象的创建过程比较麻烦，但复制比较简单的时候。
  
工厂方法：定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类当中。
  工厂方法模式的主要优点有：
    用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程；
    在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则；
    其缺点是：每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度。  
