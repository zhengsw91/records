创建型：将对象的创建和使用分离
单例模式：
  单例类只有一个实例对象；
  该单例对象必须由单例类自行创建；
  单例类对外提供一个访问该单例的全局访问点；
  懒汉式单例
  public class LazySingleton
{
    private static volatile LazySingleton instance=null;    //保证 instance 在所有线程中同步
    private LazySingleton(){}    //private 避免类在外部被实例化
    public static synchronized LazySingleton getInstance()
    {
        //getInstance 方法前加同步
        if(instance==null)
        {
            instance=new LazySingleton();
        }
        return instance;
    }
}
  饥汉式单例
  public class HungrySingleton
{
    private static final HungrySingleton instance=new HungrySingleton();
    private HungrySingleton(){}
    public static HungrySingleton getInstance()
    {
        return instance;
    }
}

原型模式：用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。
  原型模式通常适用于以下场景。
  对象之间相同或相似，即只是个别的几个属性不同的时候。
  对象的创建过程比较麻烦，但复制比较简单的时候。
  
工厂方法：定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类当中。
  工厂方法模式的主要优点有：
    用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程；
    在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则；
    其缺点是：每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度。  

抽象工厂：抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。
  抽象工厂模式的扩展有一定的“开闭原则”倾斜性：
  当增加一个新的产品族时只需增加一个新的具体工厂，不需要修改原代码，满足开闭原则。
  当产品族中需要增加一个新种类的产品时，则所有的工厂类都需要进行修改，不满足开闭原则。
  另一方面，当系统中只存在一个等级结构的产品时，抽象工厂模式将退化到工厂方法模式。
  
建造者模式：指将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示
  该模式的主要优点如下：
  各个具体的建造者相互独立，有利于系统的扩展。
  客户端不必知道产品内部组成的细节，便于控制细节风险。

  其缺点如下：
  产品的组成部分必须相同，这限制了其使用范围。
  如果产品的内部变化复杂，该模式会增加很多的建造者类。
  
  建造者（Builder）模式和工厂模式的关注点不同：建造者模式注重零部件的组装过程，而工厂方法模式更注重零部件的创建过程，但两者可以结合使用。
  
结构型模式描述如何将类或对象按某种布局组成更大的结构
  代理模式的定义：由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。

  代理模式的主要优点有：
  代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；
  代理对象可以扩展目标对象的功能；
  代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度；

  其主要缺点是：
  在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；
  增加了系统的复杂度；
  
  适配器模式（Adapter）的定义如下：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。
  该模式的主要优点如下。
  客户端通过适配器可以透明地调用目标接口。
  复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类。
  将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。
  
  其缺点是：对类适配器来说，更换适配器的实现过程比较复杂。
  适配器模式（Adapter）通常适用于以下场景。
  以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。
  使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。
  
桥接（Bridge）模式的定义如下：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。

  桥接（Bridge）模式的优点是：
  由于抽象与实现分离，所以扩展能力强；
  其实现细节对客户透明。
  缺点是：由于聚合关系建立在抽象层，要求开发者针对抽象化进行设计与编程，这增加了系统的理解与设计难度。
  
  桥接模式通常适用于以下场景。
  当一个类存在两个独立变化的维度，且这两个维度都需要进行扩展时。
  当一个系统不希望使用继承或因为多层次继承导致系统类的个数急剧增加时。
  
装饰（Decorator）模式的定义：指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式，它属于对象结构型模式。

  装饰（Decorator）模式的主要优点有：
  采用装饰模式扩展对象的功能比采用继承方式更加灵活。
  可以设计出多个不同的具体装饰类，创造出多个不同行为的组合。

  其主要缺点是：装饰模式增加了许多子类，如果过度使用会使程序变得很复杂。
  
  装饰模式在 Java 语言中的最著名的应用莫过于 Java I/O 标准库的设计了。
  例如，InputStream 的子类 FilterInputStream，OutputStream 的子类 FilterOutputStream，
  Reader 的子类 BufferedReader 以及 FilterReader，还有 Writer 的子类 BufferedWriter、
  FilterWriter 以及 PrintWriter 等，它们都是抽象装饰类。
