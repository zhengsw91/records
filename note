一）GC(垃圾回收器)
在Java中，对象实例都是在堆上创建
GC机制是有JVM提供的，用来清理需要清除的对象，回收堆内存
在java中，GC是由一个被称为垃圾回收器的守护线程执行的
在从内存回收一个对象之前会调用对象的finalize()
GC的触发由JVM依据堆内存的大小来决定，开发者不能控制
GC算法：1）标记清除算法。首先标记处所有需要回收的对象，在统一回收所有被标记的对象，缺点是效率不高并且会产生不连续的内存碎片
2）复制算法
3）标记整理算法
二）HashMap、Hashtable（未看）
HashMap线程不安全
https://yemengying.com/2016/02/03/%E8%AF%91-Java%E4%B8%ADHashMap%E5%92%8CLinkedHashMap%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%86%B2%E7%AA%81/
三）异常处理
https://blog.csdn.net/hguisu/article/details/6155636
四）锁
悲观锁（Pessimistic Lock）：
每次拿数据的时候都会担心会被别人修改（疑心重很悲观），所以每次在拿数据的时候都会上锁。确保自己使用的过程中不会被别人访问，自己使用完后再解锁。
期间需要访问该数据的都会等待。
乐观锁（Optimistic Lock）：
每次拿数据的时候都完全不担心会被别人修改（心态好很乐观），所以每次在拿数据的时候都不会上锁。但是在更新数据的时候去判断该期间是否被别人修改过（使用版本号等机制），期间该数据可以随便被其他人读取。

乐观锁比较适合数据修改比较少，读取比较频繁的场景

乐观锁应用
1.使用自增长的整数表示数据版本号。更新时检查版本号是否一致，比如数据库中数据版本为6，更新提交时version=6+1,使用该version值(=7)与数据库version+1(=7)作比较，如果相等，则可以更新，如果不等则有可能其他程序已更新该记录，所以返回错误。
2.使用时间戳来实现.
悲观锁应用
需要使用数据库的锁机制

五）spring
IoC的核心是依赖反转，将创建对象和对象之间的依赖管理交给IoC容器来做，完成对象之间的解耦。
AOP主要是利用代理模式，把许多接口都要用的又和接口本身主要的业务逻辑无关的部分抽出来，写成一个切面，单独维护，比如权限验证。
这样可以使接口符合“单一职责原则”，只关注主要的业务逻辑，也提高了代码的重用性
AOP的应用场景是权限、日志、处理异常、事务等等。

六）Redis
ImportNew
首页所有文章资讯Web架构基础技术书籍教程Java小组工具资源
面试总结
2016/09/07 | 分类： 基础技术 | 3 条评论 | 标签： 面试

分享到： 0
原文出处： Giraffe
Java相关
Java GC机制(重要程度:★★★★★)

主要从三个方面回答:GC是针对什么对象进行回收(可达性分析法)，什么时候开始GC(当新生代满了会进行Minor GC，升到老年代的对象大于老年代剩余空间时会进行Major GC)，GC做什么(新生代采用复制算法，老年代采用标记-清除或标记-整理算法)，感觉回答这些就差不多了，也可以补充一下可以调优的参数(-XX:newRatio,-Xms,-Xmx等等)。详细的可以看我另一篇博客(Java中的垃圾回收机制)。

如何线程安全的使用HashMap(重要程度:★★★★★)

作为Java程序员还是经常和HashMap打交道的，所以HashMap的一些原理还是搞搞清除比较好。这个问题感觉主要就是问HashMap，HashTable，ConcurrentHashMap，sychronizedMap的原理和区别。具体的可以看我另一篇博客(如何线程安全的使用HashMap)。

HashMap是如何解决冲突的(重要程度:★★★★☆)

其实就是链接法，将索引值相同的元素存放到一个单链表里。但为了解决在频繁冲突时HashMap性能降低的问题，Java 8中做了一个小优化，在冲突的元素个数超过设定的值(默认为8)时，会使用平衡树来替代链表存储冲突的元素。具体的可以看我另一篇博客(Java 8中HashMap和LinkedHashMap如何解决冲突)。

Java创建对象有哪几种(重要程度:★★★★☆)

这个问题还算好回答，大概有四种—new、工厂模式、反射和克隆，不过这个问题有可能衍生出关于设计模式，反射，深克隆，浅克隆等一系列问题。。。要做好准备~
参考资料：
设计模式Java版
Java反射详解
深克隆与浅克隆的区别

注解(重要程度:★★★☆☆)

如果简历中有提到过曾自定义过注解，还是了解清楚比较好。主要是了解在自定义注解时需要使用的两个主要的元注解@Retention和@Target。@Retention用来声明注解的保留策略，有CLASS，RUNTIME,SOURCE三种，分别表示注解保存在类文件，JVM运行时刻和源代码中。@Target用来声明注解可以被添加到哪些类型的元素上，如类型，方法和域等。
参考资料：
Java注解

异常(重要程度:★★★☆☆)

一道笔试题，代码如下，问返回值是什么。

1
2
3
4
5
6
7
8
9
10
11
int ret = 0;
try{
throw new Exception();
}
catch(Exception e){
ret = 1;
return ret;
}
finally{
ret = 2;
}
主要的考点就是catch中的return在finally之后执行 但是会将return的值放到一个地方存起来，所以finally中的ret=2会执行，但返回值是1。
参考资料：
深入理解Java异常处理机制
Java异常处理

悲观锁和乐观锁区别，乐观锁适用于什么情况(重要程度:★★★★☆)

悲观锁，就是总觉得有刁民想害朕，每次访问数据的时候都觉得会有别人修改它，所以每次拿数据时都会上锁，确保在自己使用的过程中不会被他人访问。乐观锁就是很单纯，心态好，所以每次拿数据的时候都不会上锁，只是在更新数据的时候去判断该数据是否被别人修改过。
大多数的关系数据库写入操作都是基于悲观锁，缺点在于如果持有锁的客户端运行的很慢，那么等待解锁的客户端被阻塞的时间就越长。Redis的事务是基于乐观锁的机制，不会在执行WATCH命令时对数据进行加锁，只是会在数据已经被其他客户端抢先修改了的情况下，通知执行WATCH命令的客户端。乐观锁适用于读多写少的情况，因为在写操作比较频繁的时候，会不断地retry，从而降低性能。
参考资料：
关于悲观锁和乐观锁的区别
乐观锁和悲观锁

单例模式找错误(重要程度:★★★★☆)

错误是没有将构造函数私有化，单例还是比较简单的，把它的饿汉式和懒汉式的两种实现方式看明白了就可以了。
单例模式

__

Spring相关
关于Spring的问题主要就是围绕着Ioc和AOP，它们真是Spring的核心啊。

Spring Bean的生命周期(重要程度:★★★★★)

就不写我那么low的回答了，直接看参考资料吧。
参考资料：
Spring Bean的生命周期
Top 10 Spring Interview Questions Answers J2EE

Spring中用到的设计模式(重要程度:★★★★★)

工厂模式:IOC容器
代理模式:AOP
策略模式:在spring采取动态代理时，根据代理的类有无实现接口有JDK和CGLIB两种代理方式，就是采用策略模式实现的
单例模式:默认情况下spring中的bean只存在一个实例
只知道这四个。。。。
参考资料:
Design Patterns Used in Java Spring Framework

讲一讲Spring IoC和AOP(重要程度:★★★★★)

IoC的核心是依赖反转，将创建对象和对象之间的依赖管理交给IoC容器来做，完成对象之间的解耦。
AOP主要是利用代理模式，把许多接口都要用的又和接口本身主要的业务逻辑无关的部分抽出来，写成一个切面，单独维护，比如权限验证。这样可以使接口符合“单一职责原则”，只关注主要的业务逻辑，也提高了代码的重用性。

AOP的应用场景(重要程度:★★★★☆)

权限，日志，处理异常，事务等等，个人理解就是把许多接口都要用的又和接口本身主要的业务逻辑无关的部分抽出来，写成一个切面，单独维护，比如权限验证。这样可以使接口符合“单一职责原则”，只关注主要的业务逻辑，也提高了代码的重用性。

Spring中编码统一要如何做(重要程度:★★★☆☆)

配置一个拦截器就行了

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
<filter>  
       <filter-name>CharacterEncodingFilter</filter-name>  
       <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>  
       <init-param>  
           <param-name>encoding</param-name>  
           <param-value>UTF-8</param-value>  
       </init-param>  
       <init-param>  
           <param-name>forceEncoding</param-name>  
           <param-value>true</param-value>  
       </init-param>  
   </filter>  
   <filter-mapping>  
       <filter-name>CharacterEncodingFilter</filter-name>  
       <url-pattern>/*</url-pattern>  
   </filter-mapping>
数据库相关
Mysql索引的内部结构(重要程度:★★★★☆)

B+树，三层，真实的数据存储在叶子节点
参考资料:
MySQL索引原理及慢查询优化

如果一个SQL执行时间比较长怎么办(重要程度:★★★★☆)

可以利用pt-query-digest等工具分析慢查询日志，也可以用explain查看SQL的执行计划。具体可看我的另一篇博客MySQL调优

如果一张表中有上千万条数据应该怎么做分页(重要程度:★★★☆☆)

肯定不能直接limit,offset，主要就是要想办法避免在数据量大时扫描过多的记录。具体可看我的另一篇博客【译】优化MySQL中的分页

什么样的列适合加索引，如果一个列的值只有1和2，那么它适合加索引么(重要程度:★★★☆☆)

在where从句，group by从句，order by从句，on从句中出现的列
索引的字段越小越好
在建立联合索引时，离散度大的列放大联合索引的前面
只有1和2不适合建索引

Redis相关
Redis提供哪几种数据结
一共有5种，字符串，散列，列表，集合，有序集合。
